import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Random;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Library {

    /*This function takes in an integer and "rolls" a 6 sided die that many times.
     * It returns an array containing the results of each roll
     * */
    public static int[] roll(int rolls) {
        int[] values = new int[rolls];
        Random rnd = new Random();
        for (int i = 0; i < values.length; i++) {
            int roll = rnd.nextInt(6) + 1;
            values[i] = roll;
        }
        return values;
    }

    /*Takes in an array of integers and returns true if there are duplicate values anywhere in the array, otherwise returns false*/
    public static boolean containsDuplicates(int[] arr) {
        for (int i = 0; i < arr.length -1; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    return true;
                }
            }
        }
        return false;
    }

    /*Takes in an array of integers, sums up all the values and divides them by the length to return the average*/
    public static double average(int[] arr) {
        double average = 0;
        for (int value : arr)
            average += value;
        return average/ (double)arr.length;
    }


    /*Accepts a 2d array and will find the average of each array and returns the array with the lowest average*/
    public static int[] lowestAverage(int[][] arraySet) {
        double lowestAvg = average(arraySet[0]);
        int lowestIndex = 0;
        for (int i = 1; i < arraySet.length; i++) {
            double setAvg = average(arraySet[i]);
            if (setAvg < lowestAvg) {
                lowestAvg = setAvg;
                lowestIndex = i;
            }
        }
        return arraySet[lowestIndex];
    }

    /*This function takes a pre-determined set of daily temperatures each week for a whole month and finds the highest and lowest temperatures along with tracking all unique temperatures.
     * It will then print out the high and low and any temperature between those two values that were not seen
     */
    public static void analyzeData() {
        int[][] weeklyMonthTemperatures = {
                {66, 64, 58, 65, 71, 57, 60},
                {57, 65, 65, 70, 72, 65, 51},
                {55, 54, 60, 53, 59, 57, 61},
                {65, 56, 55, 52, 55, 62, 57}
        };
        HashSet<Integer> temps = new HashSet<>();
        int high = weeklyMonthTemperatures[0][0];
        int low = weeklyMonthTemperatures[0][0];

        for (int[] arr : weeklyMonthTemperatures) {
            for (int temp : arr) {

                if (temp > high){
                    high = temp;
                }
                else if (temp < low) {
                    low = temp;
                }

                temps.add(temp);
            }
        }

        System.out.println("High: " + high);
        System.out.println("Low: " + low);
        for (int i = low; i < high; i++) {
            if (!temps.contains(i)) {
                System.out.println("Never saw temperature: " + i);
            }

        }
    }

    /*This function takes in a list of strings, each string being a "vote".
     * The votes are tallied in a hashmap which is then checked to find the "winner" who received the most votes
     * It will then return a string formatted as:  winner + " received the most votes!"
     * */
    public static String tally(List<String> votes) {

        //TODO: Add logic to handle the instance of a tie
        HashMap<String, Integer> tallies = new HashMap<>();

        for (String vote : votes) {
            if (tallies.containsKey(vote)) {
                tallies.put(vote, tallies.get(vote) + 1);
            }
            else {
                tallies.put(vote, 1);
            }
        }

        int highestVotes = 0;
        String winner = "";
        for (String key : tallies.keySet()) {
            if (tallies.get(key) > highestVotes) {
                highestVotes = tallies.get(key);
                winner = key;
            }
        }

        return winner + " received the most votes!";
    }
}